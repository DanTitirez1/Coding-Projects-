# -*- coding: utf-8 -*-
"""Untitled35.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SX5UOcOrHO9xW0mYxIFVhkrMoU7yCPMa
"""

#Project 001: Charged Shape
import math
import numpy as np
import matplotlib.pyplot as plt

print("Hello World")

time = 1
dt = 0.001

shape_thickness = 0.001

ran = 2

PXfinal = []
PYfinal = []
PZfinal = []


    # test metal particle
mass = 1

PX = 1.1
PY = 1
PZ = 1

VX = 0
VY = 0
VZ = 0

chargeP = 100


#make sets that store position, velocities and acceleration

chargeC = 100
Radius = 1
length = 2 * math.pi * Radius
dr = 0.001
particleNR = int(length / dr)

F = chargeP * (chargeC/(particleNR))    # force constant >>> calculate later by multiplying charges

coilX = np.zeros(particleNR)
coilY = np.zeros(particleNR)
coilZ = np.zeros(particleNR)





#make a 'rope'(function)
for i in range(particleNR):
    drA = shape_thickness * i
    """
    #loop
    coilZ[i] = 0
    coilX[i] = Radius * math.cos(drA)
    coilY[i] = 0
    '''
    #helix
    coilZ[i] = dr*i
    coilX[i] = Radius * math.cos(drA)
    coilY[i] = Radius * math.sin(drA)



    #line
    coilZ[i] = 1
    coilX[i] = dr*i
    coilY[i] = 1

    #point
    coilZ[i] = 0
    coilX[i] = 0
    coilY[i] = 0


    """
    #weird shape
    coilZ[i] = math.cos(3*drA)
    coilX[i] = math.sin(3*drA)*math.cos(5*drA)
    coilY[i] = math.sin(3*drA)*math.sin(5*drA)







#that attracts nearby particles with a strength proportional to 1/r^2

for n in range(int(time/dt)):
    r=0
    Force = 0

    ForceX = 0
    ForceY = 0
    ForceZ = 0

    rX = 0
    rY = 0
    rZ = 0

    teta = 0
    alpha = 0
    LastCumForceX = 0
    LastCumForceY = 0
    LastCumForceZ = 0

#calculating every distance( from particle to rope segment ) and the force

    CumulativeForceX = 0
    CumulativeForceY = 0
    CumulativeForceZ = 0

    for i in range(particleNR):
        r = math.sqrt( ((PX - coilX[i])** 2) + ((PY - coilY[i])** 2) + ((PZ - coilZ[i])**2) )
        Force = F * (1/pow(r,2))

        LastCumForceX = CumulativeForceX;
        LastCumForceY = CumulativeForceY;
        LastCumForceZ = CumulativeForceZ;

        ForceX = 0
        ForceY = 0
        ForceZ = 0

        rX = math.sqrt(((PX - coilX[i])**2))
        rY = math.sqrt(((PY - coilY[i])**2))
        rZ = math.sqrt(((PZ - coilZ[i])**2))

        teta = math.atan(rZ/(math.sqrt(((PX - coilX[i])** 2) + ((PY - coilY[i])** 2))))
        alpha = math.atan(rY/rX)

        #calculating force

        if PX == coilX[i]:                 #division by 0 results infinity when the output must equal 0
            ForceX = 0
        elif PX < coilX[i]:
            ForceX = Force * math.cos(teta) * math.cos(alpha)
        elif PX > coilX[i]:
            ForceX = - Force * math.cos(teta) * math.cos(alpha)

        if PY == coilY[i]:
            ForceY = 0
        elif PY < coilY[i]:
            ForceY = Force * math.cos(teta) * math.sin(alpha)
        elif PY > coilY[i]:
            ForceY = - Force * math.cos(teta) * math.sin(alpha)

        if PZ == coilZ[i]:                #division by 0 results infinity when the output must equal 0
            ForceZ = 0
        elif PZ < coilZ[i]:
            ForceZ = Force * math.sin(alpha)
        elif PZ > coilZ[i]:
            ForceZ = - Force * math.sin(alpha)

        CumulativeForceX = CumulativeForceX + ForceX
        CumulativeForceY = CumulativeForceY + ForceY
        CumulativeForceZ = CumulativeForceZ + ForceZ

    VX = VX + (CumulativeForceX/mass) * dt
    VY = VY + (CumulativeForceY/mass) * dt
    VZ = VZ + (CumulativeForceZ/mass) * dt

    PX = PX + (VX) * dt + 0.5 * (CumulativeForceX/mass) * (dt **2)
    PY = PY + (VY) * dt + 0.5 * (CumulativeForceY/mass) * (dt **2)
    PZ = PZ + (VZ) * dt + 0.5 * (CumulativeForceZ/mass) * (dt **2)

    PXfinal.append(PX)
    PYfinal.append(PY)
    PZfinal.append(PZ)

ax = plt.figure().add_subplot(projection='3d')

# Plot a sin curve using the x and y axes.

ax.plot(coilX, coilY, coilZ, zdir='z', label='curve in (x, y)')

ax.plot(PXfinal, PYfinal, PZfinal, zdir='z', label='curve in (x, y)')

ax.set_xlim(-ran, ran)
ax.set_ylim(-ran, ran)
ax.set_zlim(-ran, ran)

#ax.set_xlabel('X t=100, dt=0.0001')
#ax.set_ylabel('Y')
#ax.set_zlabel('Z')

#Project 002: The 3 body problem

import math

import matplotlib.pyplot as plt

dt = 0.0001

time = 20

masssqrt = 1000

ran = 100




F = 10

PX = [0.5,0.95,0.3]
PY = [0,0.3,-0.3]
PZ = [0,0,0]

VX = [0,0,0]
VY = [0,0,0]
VZ = [0,0,0]

AX = [0,0,0]
AY = [0,0,0]
AZ = [0,0,0]

AXC = [0,0,0]
AYC = [0,0,0]
AZC = [0,0,0]

PXfinal0 = []
PYfinal0 = []
PZfinal0 = []

PXfinal1 = []
PYfinal1 = []
PZfinal1 = []

PXfinal2 = []
PYfinal2 = []
PZfinal2 = []



particleNR = len(PX)

def Force():

    for n in range(particleNR):
        AXC[n] = 0
        AYC[n] = 0
        AZC[n] = 0
        for m in range(particleNR):

            if n != m :

                rX = math.sqrt(((PX[n] - PX[m])**2))
                rY = math.sqrt(((PY[n] - PY[m])**2))
                rZ = math.sqrt(((PZ[n] - PZ[m])**2))

                distance = math.sqrt( (PX[n]-PX[m])**2 + (PY[n]-PY[m])**2 + (PZ[n]-PZ[m])**2 )

                Force = masssqrt * F * (1/(distance**2))

                teta = math.atan(rZ/(math.sqrt(((PX[n] - PX[m])** 2) + ((PY[n] - PY[m])** 2))))
                alpha = math.atan(rY/rX)

                if PX[n] == PX[m]:                 #division by 0 results infinity when the output must equal 0
                    AX[n] = 0
                elif PX[n] < PX[m]:
                    AX[n] = Force * math.cos(teta) * math.cos(alpha)
                elif PX[n] > PX[m]:
                    AX[n] = - Force * math.cos(teta) * math.cos(alpha)

                if PY[n] == PY[m]:
                    AY[n] = 0
                elif PY[n] < PY[m]:
                    AY[n] = Force * math.cos(teta) * math.sin(alpha)
                elif PY[n] > PY[m]:
                    AY[n] = - Force * math.cos(teta) * math.sin(alpha)

                if PZ[n] == PZ[m]:                #division by 0 results infinity when the output must equal 0
                    AZ[n] = 0
                elif PZ[n] < PZ[m]:
                    AZ[n] = Force * math.sin(alpha)
                elif PZ[n] > PZ[m]:
                    AZ[n] = - Force * math.sin(alpha)

                AXC[n] = AXC[n] + AX[n]
                AYC[n] = AYC[n] + AY[n]
                AZC[n] = AZC[n] + AZ[n]

                VX[n] = VX[n] + (AXC[n]) * dt
                VY[n] = VY[n] + (AYC[n]) * dt
                VZ[n] = VZ[n] + (AZC[n]) * dt

                PX[n] = PX[n] + (VX[n]) * dt + 0.5 * (AXC[n]) * (dt **2)
                PY[n] = PY[n] + (VY[n]) * dt + 0.5 * (AYC[n]) * (dt **2)
                PZ[n] = PZ[n] + (VZ[n]) * dt + 0.5 * (AZ[n]) * (dt **2)

                if n == 0:
                    PXfinal0.append(PX[n])
                    PYfinal0.append(PY[n])
                    PZfinal0.append(PZ[n])

                if n == 1:
                    PXfinal1.append(PX[n])
                    PYfinal1.append(PY[n])
                    PZfinal1.append(PZ[n])

                if n == 2:
                    PXfinal2.append(PX[n])
                    PYfinal2.append(PY[n])
                    PZfinal2.append(PZ[n])







for i in range(int(time/dt)):
    Force()


ax = plt.figure().add_subplot(projection='3d')


ax.plot(PXfinal0, PYfinal0, PZfinal0, zdir='z', label='curve in (x, y)')
ax.plot(PXfinal1, PYfinal1, PZfinal1, zdir='z', label='curve in (x, y)')
ax.plot(PXfinal2, PYfinal2, PZfinal2, zdir='z', label='curve in (x, y)')

ax.set_xlim(-ran, ran)
ax.set_ylim(-ran, ran)
ax.set_zlim(-ran, ran)